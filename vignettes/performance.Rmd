---
title: "performance"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{performance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(truncsm)
library(Rfast)
```
```{r truncsm_mod}
truncsm2 = function(x, dV){
  psi =  function(theta, x){
    Cov = diag(1/10, nrow=length(theta), ncol=length(theta))
    Cov_inv = solve(Cov)
    return(list("f"=-Cov_inv %*% (x-theta), "grad"=-Cov_inv))
  }
  g=truncsm::g_def(x, dV)
  gvals = g$g; ggrad = g$grad
  J_wrap = function(theta){
    theta = truncsm:::spherical_bounds(theta)
    J_(theta, x, dV, psi, gvals, ggrad)
  }
  est = optim(colMeans(x), J_wrap)
  est$par
}
J_ = function(theta, x, dV, psi, g_val, g_grad){
  dpsi_eval = array(NA, c(nrow(x),ncol(dV),ncol(dV)))
  psi_eval = array(NA, c(nrow(x), ncol(dV)))
  for(i in 1:nrow(x)) {
    psi_out = psi(theta, x[i,])
    dpsi_eval[i,,] = psi_out$grad
    psi_eval[i,] = psi_out$f
  }
  term1 = mean(rowSums(psi_eval^2 * g_val))
  term2 = 2*mean(sum(apply(dpsi_eval, 1, function(y)sum(diag(y)))*g_val))
  term3 = 2*mean(rowSums(psi_eval*g_grad))
  term1 + term2 + term3
}
```

```{r cache=TRUE, eval=FALSE}
# Create new centre point (slightly below equator) and boundary
centre = c(pi/2, pi)
centre_euclid = sphere_to_euclid(centre)
dV = cbind(rep(pi/2, 100), seq(0, 2*pi, len=100))
z_dV = sphere_to_euclid(dV)

nseq = seq(100, 1600, len=40) 
N = 40 
errors = array(NA, c(length(nseq), N, 4)); dimnames(errors)[[3]] = c("Disk", "Hav", "TruncSM", "Mean")
centres = array(NA, c(length(nseq), N, 4, 2)); dimnames(centres)[[3]] = c("Disk", "Hav", "TruncSM","Mean")
dimnames(centres)[[4]] = c("Theta", "Phi")
dimnames(centres)[[1]] = dimnames(errors)[[1]] = nseq
for(i in 1:length(nseq)){
  ni = round(nseq[i])
  
  for(j in 1:N){
    # Simulate from VMF distribution
    set.seed(3*j)    # same seed every time, only thing that changes is no of samples
    z = rvmf(ni, centre_euclid, k=10) 
    x = euclid_to_sphere(z)
    x = truncsm:::spherical_bounds(x)
    
    # take truncated points (above line)
    above_boundary = x[,1] > pi/2
    truncated_x = x[above_boundary,]
    truncated_z = z[above_boundary,]
    
    # Fit
    centre_disk = sphere_sm(truncated_z, z_dV, g="Euclidean")
    centre_hav = sphere_sm(truncated_z, z_dV, g="Haversine")
    centre_reg = truncsm2(truncated_x, dV)
    centre_avg = colMeans(truncated_x)

    # Save errors
    errors[i, j, "Disk"] = sqrt(sum((centre - centre_disk)^2))
    errors[i, j, "Hav"] = sqrt(sum((centre - centre_hav)^2))
    errors[i, j, "TruncSM"] = sqrt(sum((centre - centre_reg)^2))
    errors[i, j, "Mean"] = sqrt(sum((centre - centre_avg)^2))
    
    # Save centres
    centres[i, j, "Disk", ] = centre_disk 
    centres[i, j, "Hav", ] = centre_hav
    centres[i, j, "TruncSM", ] = centre_reg 
    centres[i, j, "Mean",] = centre_avg
  }
  cat("\r", i, "/", length(nseq)); flush.console()
}; cat("\n")

# Get Means/SD
error_mean = apply(errors, c(1,3), mean)
error_sd = apply(errors, c(1,3), sd)
centre_mean = apply(centres, c(1,3,4), mean)
centre_sd = apply(centres, c(1,3,4), sd)
```

```{r, eval=FALSE}
library(ggplot2)
# theta_centres = data.frame(mean = as.vector(centre_mean[,,"Theta"]), 
#                            sd = as.vector(centre_sd[,,"Theta"]), 
#                            method = c(rep("Disk", length(nseq)), 
#                                       rep("Hav", length(nseq)), rep("Mean", length(nseq))),
#                            n = rep(nseq, 3))
# gg1 = ggplot(theta_centres) + geom_point(aes(x=n, y=mean, col=method)) + 
#   geom_line(aes(x=n, y=mean, col=method)) + geom_hline(aes(yintercept = centre[1]), size=.4, col="grey") +  xlab(expression(n)) + ylab(expression(theta)) + 
#    geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method), alpha=.3) + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=16)) 
# 
# phi_centres = data.frame(mean = as.vector(centre_mean[,,"Phi"]), 
#                            sd = as.vector(centre_sd[,,"Phi"]), 
#                          method = c(rep("Disk", length(nseq)), 
#                                     rep("Hav", length(nseq)), rep("Mean", length(nseq))),
#                          n = rep(nseq, 3))
# gg2 = ggplot(phi_centres) + geom_point(aes(x=n, y=mean, col=method)) + 
#   geom_line(aes(x=n, y=mean, col=method)) + geom_hline(aes(yintercept = centre[2]), size=.4, col="grey") +  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method), alpha=.3) + 
#   xlab(expression(n)) + ylab(expression(phi)) +
#   theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=16))


error_data =  data.frame(mean = as.vector(error_mean), 
                         sd = as.vector(error_sd),
                         method = c(rep("Disk", length(nseq)), rep("Hav", length(nseq)), 
                                    rep("TruncSM", length(nseq)), rep("Mean", length(nseq))),
                         n = rep(nseq, 4))
gg1 = ggplot(error_data[error_data$method=="Disk",]) + geom_point(aes(x=n, y=mean),size=2.5, col="blue") + geom_line(aes(x=n, y=mean), col="blue") + geom_hline(aes(yintercept = 0), size=.4, col="black") + 
  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd), alpha=.3, col="blue", fill="blue") + xlab(expression(n)) + ylab("Error") + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=20)) + ggtitle("Euclidean")

gg2 = ggplot(error_data[error_data$method=="Hav",]) + geom_point(aes(x=n, y=mean),size=2.5, col="red") + geom_line(aes(x=n, y=mean), col="red") + geom_hline(aes(yintercept = 0), size=.4, col="black") + 
  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd), alpha=.3, col="red", fill="red") + xlab(expression(n)) + ylab("Error") + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=20)) + ggtitle("Haversine")

gg3 = ggplot(error_data[error_data$method=="TruncSM",]) + geom_point(aes(x=n, y=mean),size=2.5, col="green") + geom_line(aes(x=n, y=mean), col="green") + geom_hline(aes(yintercept = 0), size=.4, col="black") + 
  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd), alpha=.3, col="green", fill="green") + xlab(expression(n)) + ylab("Error") + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=20)) + ggtitle("TruncSM")

library(gridExtra)
library(grid)
grid.arrange(gg1, gg2, gg3, ncol=1, top=textGrob("Estimated Centres", 
                                            gp = gpar(fontsize=20, fontface="bold"), hjust=.6))
error2 = error_data[error_data$method!="Mean",]
ggplot(error2) + geom_point(aes(x=n, y=mean),size=2.5) + geom_line(aes(x=n, y=mean,  col=method)) + geom_hline(aes(yintercept = 0), size=.4, col="black") + 
  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method, fill=method), alpha=.3) + xlab(expression(n)) + ylab("Error") + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=20)) + ggtitle("All")

```


## Parameters of Kent Distribution

```{r cache=TRUE, eval=FALSE}
# Create new centre point (slightly below equator) and boundary
centre = c(pi/2, pi)
centre_euclid = sphere_to_euclid(centre)
dV = cbind(rep(pi/2, 100), seq(0, 2*pi, len=100))
z_dV = sphere_to_euclid(dV)

nseq = seq(100, 1600, len=40) 
N = 50 
centres = array(NA, c(length(nseq), N, 3, 3)); dimnames(centres)[[3]] = c("Disk", "Hav", "Mean")
dimnames(centres)[[4]] = c("dir", "Major", "Minor")
dimnames(centres)[[1]] = dimnames(errors)[[1]] = nseq
for(i in 1:length(nseq)){
  ni = round(nseq[i])
  set.seed(i)
  bval = runif(1,0,6)
  psi_kent = function(par, x, k=10, beta=bval){
    gamma1 = par[,1]
    gamma2 = par[,2]
    gamma3 = par[,3]
    list(
      "f" = k*gamma1 + 2*beta*(gamma2 %*% t(gamma2 %*% x) - gamma3 %*% t(gamma3 %*% x)),
      "grad" = 2*beta*(gamma2 %*% t(gamma2) - gamma3 %*% t(gamma3))
    )
  }
  for(j in 1:N){
    # Simulate from VMF distribution
    set.seed(3*j)    # same seed every time, only thing that changes is no of samples
    z = rkent(ni, centre_euclid, k=10, b = bval) 
    x = euclid_to_sphere(z)
    x = truncsm:::spherical_bounds(x)
    
    # take truncated points (above line)
    above_boundary = x[,1] > pi/2
    truncated_x = x[above_boundary,]
    truncated_z = z[above_boundary,]
    
    # Fit
    init = rep(colMeans(x),3); dim(init) = c(2,3)
    est_disk = sphere_sm(truncated_z, z_dV, g="Euclidean", init = init, options = list(psi = psi_kent))
    est_hav = sphere_sm(truncated_z, z_dV, g="Haversine", init = init, options = list(psi = psi_kent))
    
    est_avg = colMeans(truncated_x)

    # MLE on full dataset
    mle = kent.mle(z)$G
    mle_est = apply(mle, 2, euclid_to_sphere)
    
    # Save centres
    centres[i, j, "Disk", ] = sqrt(sum((est_disk - mle_est)^2)) 
    centres[i, j, "Hav", ] = sqrt(sum((est_hav - mle_est)^2))  
    centres[i, j, "Mean",] = sqrt(sum((est_avg - mle_est)^2)) 
  }
  cat("\r", i, "/", length(nseq)); flush.console()
}; cat("\n")

# Get Means/SD
centre_mean = apply(centres, c(1,3,4), mean)
centre_sd = apply(centres, c(1,3,4), sd)
```
```{r, eval=FALSE}
library(ggplot2)
dir_centres = data.frame(mean = as.vector(centre_mean[,,"dir"]), 
                           sd = as.vector(centre_sd[,,"dir"]), 
                           method = c(rep("Disk", length(nseq)), 
                                      rep("Hav", length(nseq)), rep("Mean", length(nseq))),
                           n = rep(nseq, 3))
gg1 = ggplot(dir_centres) + geom_point(aes(x=n, y=mean, col=method)) + 
  geom_line(aes(x=n, y=mean, col=method))+  xlab(expression(n)) + ylab(expression(dir)) + 
   geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method), alpha=.3) + theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=16)) 

Major_centres = data.frame(mean = as.vector(centre_mean[,,"Major"]), 
                           sd = as.vector(centre_sd[,,"Major"]), 
                         method = c(rep("Disk", length(nseq)), 
                                    rep("Hav", length(nseq)), rep("Mean", length(nseq))),
                         n = rep(nseq, 3))
gg2 = ggplot(Major_centres) + geom_point(aes(x=n, y=mean, col=method)) + 
  geom_line(aes(x=n, y=mean, col=method)) +  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method), alpha=.3) + 
  xlab(expression(n)) + ylab(expression(Major)) +
  theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=16))


Minor_centres = data.frame(mean = as.vector(centre_mean[,,"Minor"]), 
                           sd = as.vector(centre_sd[,,"Minor"]), 
                         method = c(rep("Disk", length(nseq)), 
                                    rep("Hav", length(nseq)), rep("Mean", length(nseq))),
                         n = rep(nseq, 3))
gg3 = ggplot(Minor_centres) + geom_point(aes(x=n, y=mean, col=method)) + 
  geom_line(aes(x=n, y=mean, col=method)) +  geom_ribbon(aes(x=n, ymin=mean-sd, ymax=mean+sd, col=method), alpha=.3) + 
  xlab(expression(n)) + ylab(expression(Minor)) +
  theme_minimal() + theme(text = element_text(size=15), axis.title = element_text(size=16))

library(gridExtra)
library(grid)
grid.arrange(gg1, gg2, gg3, ncol=1, top=textGrob("Estimated Pars", 
                                            gp = gpar(fontsize=20, fontface="bold"), hjust=.6))

```
